# 스프링 MVC 1편 - 백엔드 웹 개발 핵심 기술
---

## 웹 애플리케이션 이해
2023.08.07

### 웹 서버, 웹 애플리케이션 서버
웹 세상은 HTTP 기반으로 돌아간다.

#### 모든 것은 HTTP
- HTTP 메시지에 모든 것을 전송함.
- HTML, TEXT
- IMAGE, 음성, 영상, 파일
- JSON, XML (API)
- 거의 모든 형태의 데이터 전송
- 서버간 데이터를 주고 받을 때도 배부분 HTTP 사용

#### 웹 서버
- HTTP 기반 동작
- 정적 리소스 제공, 기타 부가기능
- 예) NGINX, APACHE

#### 웹 애플리케이션 서버
- HTTP 기반 동작
- 웹 서버 기능 포함
- 프로그램 코드를 실행해 애플리케이션 로직 수행
  - 동적 HTML, HTTP API(JSON)
  - 서블릿, JSP, 스프링 MVC
- 예) 톰캣 Jetty, Undertow

#### 차이
- 웹 서버는 정적 리소스, WAS는 애플리케이션 로직
- 사실 용어도 경계도 모호함
- 자바는 서블릿 컨테이너 기능을 제공하면 WAS(이것도 애매)
- WAS는 애플리케이션 코드 실행에 더 특화

#### 웹 시스템 구성 - WAS, DB
- WAS가 너무 많은 역할 담당
- 비싼 애플리케이션 로직이 정적 리소스 때문에 수행 어려울 수 있음
- WAS 장애시 오류 화면도 노출 불가

#### 웹 시스템 구성 - WEB SERVER, WAS, DB
- 정적 리소스를 웹 서버가 처리
- 애플리케이션 로직은 WAS가 처리
- 애플리케이션 로직같은 동적 처리가 필요하면 WAS에 요청을 위임
- 효율적인 리소스 관리
  - 정적 리소스가 많이 사용되면 WEB SERVER 증설
  - 애플리케이션 리소스가 많이 사용되면 WAS 증설
- WAS, DB 장애시 WEB 서버가 오류 화면 제공 가능

### 서블릿

#### 서버에서 처리해야 하는 업무
- 만약 웹 애플리케이션 서버를 직접 구현한다면?
  - 서버 TCP/IP 연결 대기, 소캣 연결
  - HTTP 요청 메시지 파싱해서 읽기
  - HTTP METHOD, URL 인지
  - Content-Type 확인
  - HTTP 메시지 바디 내용 파싱
  - 프로세스 실행
  - 비즈니스 로직 실행
    - DB에 요청
  - HTTP 응답 메시지 생성 시작
    - HTTP 시작 라인 생성
    - Header 생성
    - 메시지 바디에 HTML 생성에서 입력
  - TCP/IP에 응답 전달, 소켓 종료

- 서블릿을 지원하는 WAS 사용하면
  - 비즈니스 로직 실행에만 집중 가능
  - URL이 호출되면 서블릿 코드 실행
  - HTTP 요청 정보를 편리하게 사용할 수 있는 HttpServletRequest
  - HTTP 응답 정보를 편리하게 사용할 수 있는 HttpServletResponse
  - 개발자가 HTTP 스펙을 매우 편리하게 사용

#### 서블릿 HTTP 요청, 응답 흐름
- HTTP 요청시
  - WAS는 Request, Response 객체를 새로 만들어 서블릿 객체 호출
  - Request 객체에서 HTTP 요청 정보를 편하게 꺼내 사용
  - Response 객체에서 HTTP 응답 정보를 편리하게 입력
  - WAS는 Response 객체에 담긴 내용으로 HTTP 응답 정보 생성

#### 서블릿 컨테이너
- 톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 함
- 서블릿 컨테이너는 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기 관리
- 싱글톤으로 관리
  - 공유변수 사용 주의
- JSP도 서블릿으로 변환되어서 사용
- 동시 요청을 위한 멀티 쓰레드 처리 지원

### 동시 요청 - 멀티 쓰레드

#### 쓰레드
- 애플리케이션 코드를 순차적으로 실행하는 것 = 쓰레드
- 자바 메인 메서드는 main이라는 이름의 쓰레드로 실행
- 한번에 하나의 코드 라인만 수행
- 동시 처리가 필요하면 쓰레드 추가로 생성

#### 쓰레드 하나에 다중 요청이라면
- 요청 1이 끝나기 전까지 요청 2는 대기해야 할 것
- 요청 1에서 어떤 문제가 생겨서 지연된다면 요청 2는 끊임없이 기다려야 함

#### 쓰레드를 요청마다 생성한다면
- 장점
  - 동시 요청 처리 가능
  - 리소스(CPU, 메모리)가 허용할 때까지 처리 가능
  - 하나의 쓰레드가 지연 되어도, 나머지 쓰레드 정상 동작
- 단점
  - 쓰레드 생성 비용 매우 비쌈;;
    - 요청마다 생성 시 응답 속도 느려짐
  - 쓰레드는 컨텍스트 스위칭 비용 발생
  - 쓰레드 생성 제한이 없음
    - 요청 너무 많이오면 임계점 넘어서 서버 사망..

#### 쓰레드 풀
- 필요한 쓰레드를 쓰레드 풀에 보관하고 관리
- 쓰레드 풀에 생성 가능한 쓰레드의 최대치 관리. 톰캣은 최대 200개 기본 설정(변경 가능)

- 쓰레드 필요하면, 이미 생성된 쓰레드를 풀에서 꺼내 사용
- 사용 끝나면 풀에 반납
- 최대 쓰레드가 모두 사용중이라면?
  - 기다리는 요청은 거절하거나 특정 숫자만큼만 대기하도록 설정

- 쓰레드가 모두 생성되어 있으니 생성 종료하는 비용이 절약되고 응답 시간 빠름
- 생성 가능한 쓰레드 최대치가 있으므로 너무 많이 요청 들어와도 기존 요청 안전하게 처리 가능

#### 실무 팁
- WAS의 주요 튜닝 포인트는 최대 쓰레드 수이다.
- 이 값이 너무 낮으면?
  - 동시 요청이 많으면, 서버 리소스 여유롭지만, 클라이언트는 금방 응답이 지연됨
- 너무 높으면?
  - 동시 요청이 많으면, CPU, 메모리 리소스 임계점 초과로 서버 다운
- 장애 발생시?
  - 틀라우드면 일단 서버부터 늘리고, 이후에 튜닝..
  - 클라우드 아니면 열심히 튜닝..

- 적정 숫자는??
  - 애플리케이션 로직의 복잡도, CPU, 메모리, IO 리소스 상황에 따라 모두 다름
  - 성능 테스트
    - 최대한 실제 서비스와 유사하게 성능 테스트 시도
    - 툴: 아파치 ad, 제이미터, nGrinder

#### WAS의 멀티쓰레드 지원
- 멀티 쓰레드에 대한 부분은 WAS가 처리
- 개발자는 멀티 쓰레드 관련 코드를 신경쓰지 않아도 됨
- 개발자는 마치 싱글 쓰레드 프로그래밍을 하듯 편리하게 소스코드 개발
- 멀티 쓰레드 환경이므로 싱글톤 객체를 주의하여 사용

### HTML, HTTP API, CSR, SSR

#### 정적 리소스
- 고정된 HTML 파일, CSS, JS, 이미지, 영상 등을 제공
- 주로 웹 브라우저

#### HTML 페이지
- 동적으로 필요한 HTML 파일 생성해서 전달
- 웹 브라우저: HTML 해석

#### HTTP API
- HTML이 아니라 데이터 전달
- 주로 JSON 형식
- 다양한 시스템에서 호출
- 데이터만 주고 받음
- 다양한 시스템 연동
- UI 클라이언트 접점
  - 앱, 웹
- 서버 to 서버
  - 기업간 데이터 통신

#### SSR
- 서버 사이드 렌더링
  - HTML 최종 결과를 서버에서 만들어 웹브라우저에 전달
  - 주로 정적 화면에 사용
  - 관련 기술: JSP, 타임리프 -> 백엔드 개발자
- 클라이언트 사이드 렌더링
  - HTML 결과를 JS를 사용해 웹 브라우저에서 동적으로 생성해서 적용
  - 주로 동적인 화면 사용, 웹 환경을 마치 앱처럼 부분 변경 가능
  - 예) 구글 지도, 구글 캘린더
  - 관련기술: React, Vue.js -> 웹 프론트엔드 개발자

### 자바 백엔드 웹 기술 역사

#### 과거 기술
- 서블릿 - 1997
- JSP - 1999
- 서블릿, JSP 조합 MVC 패턴 사용
  - 모델, 뷰, 컨트롤러
- MVC 프레임워크 춘추 전국 시대 - 2000초 - 2010초
    - MVC 패턴 자동화, 복잡한 웹 기술 편리하게 사용하는 다양한 기능 지원
    - 스트럿츠, 웹워크, 스프링 MVC

#### 현재 사용 기술
- 애노테이션 기반의 스프링 MVC 등장
  - @Controller
  - 이 전쟁을 끝내러 왔다
- 스프링 부트 등장
  - 스프링 부트는 서버 내장
  - 과거 WAS를 직접 설치하고, 소스는 War 파일 만들어 설치한 WAS에 배포
  - 스프링 부트는 빌드 결과에 WAS 서버 포함 -> 빌드 배포 단순화

#### 최신 기술 - 스프링 웹 기술의 분화
- Web Servlet - Spring MVC
- Web Reactive - Spring WebFlux

#### 스프링 웹 플럭스
- 비동기 넌 블러킹 처리
- 최소 쓰레드로 최대 성능 - 쓰레드 컨텍스트 스위칭 비용 효율화
- 함수형 스타일로 개발- 동시처리 코드 효율화
- 서블릿 기술 사용 X
- but
  - 기술적 난이도 높음
  - RDB 지원 부족
  - 일반 MVC 쓰레드 모델도 충분히 빠름

#### 자바 뷰 템플릿 역사
- JSP
  - 느림.. 기능 부족
- 프리마커, 벨로시티
  - 속도 문제 해결, 다양한 기능
- Thymeleaf
  - 내추럴 템플릿: HTML 모양 유지하며 뷰 템플릿 적용
  - 스프링 MVC와 강력한 기능 통합
  - 최선의 선택

---

## 서블릿
2023.08.09

### 스프링 부트 서블릿 환경 구성
- `@ServletComponentScan`을 사용해 서블릿을 직접 등록해 사용할 수 있도록 한다.

### 서블릿 등록
- `@WebServlet` 어노테이션
  - name: 서블릿 이름
  - urlPattern: URL 매핑
- `HttpServlet` 상속
  - `protected void service(HttpServletRequest req, HttpServletResponse res)` 을 구현하여 요청 처리 및 응답

### HTTP 요청 메시지 로그로 확인하기
- `application.properties` : `logging.level.org.apache.coyote.http11=debug
- 개발 단계에서만 사용하자(성능 저하 고려)

### 서블릿 컨테이너 동작 방식
- 스프링 부트가 내장 톰켓 서버를 생성
- 톰켓 : 웹 애플리케이션 서버 + 서블릿 컨테이너
- 웹 애플리케이션 서버로 들어오는 Http 요청 메시지 기반으로 request, response 생성
- 서블릿 컨테이너가 그 request를 처리하고 response에 응답 생성

### HttpServletRequest 역할
- HTTP 요청 메시지를 편리하게 사용할 수 있도록 대신 파싱
- 그 결과를 `HttpServletRequest`에 담아서 제공
- 여러 Http 요 메시지를 편리하게 조회 가능
- 부가 기능 제공
  - 임시 값 저장
  - 세션 관리
- Http 요청 메시지의 start-line , header, 데이터 정보를 조회 가능

### Http 요청 데이터
HTTP 요청 메시지를 통해 클라이언트가 서버로 데이터를 전달하는 방법은 주고 3가지
- GET - 쿼리 파라미터
  - /url?param1=val1&param2=val2
  - 메시지 바디 없이, URL의 쿼리 파라미터에 데이터 전달
  - 예) 검색, 필터, 페이징 등에서 많이 사용하는 방식
- POST - HTML Form
  - content-type: application/x-www-form-urlencoded
  - 메시지 바디에 쿼리 파라미터 형식으로 전달
  - 예) 회원 가입, 상품 주문, HTML Form 사용
- HTTP message body
  - HTTP API에서 주로 사용 JSON, XML, TEXT
  - 주로 JSON 사용(사실상 표준)

#### 조회 메서드
- 쿼리 파라미터와 POST 요청의 형식이 서로 같음
    - `HttpServletRequest`가 제공하는 `getParameter()` 함수로 조회 가능
    - 복수 파라미터일 때는.. 이런 경우는 거의 없지만 `getParameterValues()` 제공함
    - GET은 쿼리 파라미터
    - POST는  `content-type:application/x-www-form-urlencoded` 헤더에 추가되고 메시지 바디에 쿼리 파라미터와 같은 형식으로 데이터 전달
- API 메시지 바디
  - Http 메시지 바디 데이터는 `InputStream`을 사용해 직접 읽을 수 있음
  - 이 때 `inputStream`이 반환하는 바이트 코드를. 우리가 읽을 수 있는 문자로 볼 수 있게 `utf-8`로 지정해준다.
  - Json 방식일 때는 Json 형식에 맞춰 데이터를 객체로 받을 수 있는 클래스를 작성한다.
  - Json 파싱에 도움을 주는 라이브러리를 사용하여 파싱한다.
  - Spring에서는 Jackson 라이브러리를 기본으로 제공한다.

### HttpServletResponse 역할
- HTTP 응답 메시지 생성
  - HTTP 응답코드 지정
  - 헤더 생성
  - 바디 생성
- 편의 기능 제공
  - Content-Type
  - 쿠키
  - Redirect

### HTTP 응답 데이터
- 단순 텍스트 응답
  - `writer.println("ok");`
- HTML 응답
  - `writer.println("<html>");` 등으로 집어 넣기
- HTTP API - MessageBody JSON 응답
  - `objectMapper.writeValueAsString(data);` : 객체를 Json 문자로 변경

---

# 서블릿, JSP, MVC 패턴
2023.08.11

## 서블릿으로 웹 애플리케이션 만들기
- 서블릿으로 작성 시 자바 코드로 HTML을 제공해야 하므로 굉장히 귀찮은 작업이다..
- 하지만 동적으로 HTML 페이지를 내보낼 수 있다는 장점도 있다.

### 템플릿 엔진으로
- 서블릿을 통해 동적으로 원하는 HTML 작성 가능
- but 매우 복잡하고 비효율적
- 템플릿 엔진을 사용해 HTML 문서에 필요한 곳만 코드를 적용해 동적으로 변경

## JSP로 웹 애플리케이션 만들기

### 라이브러리 추가

- `build.gradle`에 추가
  ```groovy
  //JSP 추가 시작
  implementation 'org.apache.tomcat.embed:tomcat-embed-jasper'
  implementation 'javax.servlet:jstl' //JSP 추가 끝
  ```
- `<%@ page contentType="text/html;charset=UTF-8" language="java" %>`
  - JSP 문서라는 뜻
- `<%@ page import="" %>`
  - 자바 import
- `<% %>` 
  - 자바 코드 추가
- `<%= %>`
  - 자바 코드 출력

### 서블릿 JSP 한계
- JSP는 비즈니스 로직과 뷰 영역이 섞여있다.
- 다양한 코드가 JSP에 노출된다.
- JSP가 너무 많은 역할을 한다.

#### MVC 패턴 등장
- 비즈니스 로직은 서블릿처럼 다른 곳에서 처리하고, JSP는 목적에 맞게 HTML로 화면을 그리는데 집중시키자!!

### MVC 패턴

#### 너무 많은 역할
- 하나의 서블릿이나 JSP만으로 로직과 뷰를 모두 처리하면 유지보수 어려워짐

#### 변경의 라이프 사이클
- 둘 사이의 변경 라이프 사이클이 다름
- 로직 수정과 UI 수정은 다르게 발생할 가능성이 높고 대부분 서로에게 영향 주지 않음

#### 기능 특화
- 각자가 최적화된 것들을 사용해 업무를 담당하는 것이 좋음

#### Model View Controller
- 컨트롤러: HTTP 요청을 받아 파라미터를 검증하고, 비즈니스 로직 실행. 뷰에 전달 결과 데이터 조회해 모델에 담음.
- 모델: 뷰에 출력할 데이터 담아둠. 뷰는 비즈니스 로직이나 데이터 접근을 모른채로 화면 렌더링에만 집중 가능
- 뷰: 모뎅에 담긴 데이터를 사용해 화면을 그리는 것에 집중
- 서비스: 컨트롤러에 비즈니스 로직을 두지 않고 서비스 계층을 별도로 만들어 처리.

#### MVC 패턴 적용
- 서블릿을 컨트롤러로 사용
- JSP를 뷰로 사용
- Model로는 HttpServletRequest 객체 사용
  - `request.setAttribute()`, `request.getAttribute()` 사용해 데이터 보관 및 조회
- `dispatcher.forward()`를 통해 다른 서블릿이나 JSP로 이동. 서버 내부에서 다시 호출
- JSP의 `${}` 문법을 통해 request의 attribute에 담긴 데이터 편리하게 조회 가능

> `/WEB-INF`
> 이 경로 안에 JSP는 외부에서 직접 호출 불가. 항상 컨트롤러를 통해 호출

> redirect vs forward
> 리다이렉트는 실제 클라이언트에 응답이 나갔다가 클라이언트가 redirect 경로로 다시 요청. 클라이언트가 인지 가능하고 URL 경로도 변경됨
> 포워드는 서버 내부에서 일어나는 호출로 클라이언트 인지 불가능

#### MVC 패턴 한계
- 포워드 중복
- ViewPath에 중복
  - prefix: `/WEB-INF/views/`
  - suffix: `.jsp`
  - 만약 다른 뷰로 변경하면 코드 전체 다 변경해야 함
- 사용하지 않는 코드
  - `response` 사용 안하는 경우가 있음
- 공통 처리 어려움
  - 기능이 복잡해지면 공통 처리 부분이 많을 것.
  - 메소드로 뽑아도 항상 호출해야하고 중복됨
- 수문장 역할을 하는 프론트 컨트롤러 패턴을 도입해 한계 극복

---

# MVC 프레임워크 만들기
2023.08.17

## 프론트 컨트롤러 패턴
- 프론트 컨트롤러 서블릿 하나로 클라이언트의 요청을 받는다.
- 프론트 컨트롤러가 요청에 맞는 컨트롤러를 찾아서 호출
- 입구를 하나로
- 공통 처리 가능
- 프론트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도 됨

스프링 웹 MVC의 DispatcherServlet이 FrontController 패턴으로 구현됨

## V1
프론트 컨트롤러를 단계적으로 도입.
이번 목표는 기존 코드를 최대한 유지하면서, 프론트 컨트롤러를 도입하는 것이다.
먼저 구조를 맞추어두고 점진적으로 리펙터링.

- 서블릿과 비슷한 모양의 컨트롤러 인터페이스 도입
- 인터페이스를 호출해 구현과 관계없이 로직의 일관성 가져갈 수 있다

### 프론트 컨트롤러 분석
- `urlPatterns = "/front-controller/v1/*'`: `/front-controller/v1`을 포함한 하위 모든 요청을 이 서블릿에서 받음
- controllerMap
  - key: 매핑 URL
  - value: 호출된 컨트롤러
- service(): 먼저 `requestURI`조회한 뒤 실제 컨트롤러를 `controllerMap`에서 찾음. 없으면 404 상태코드 반환. 컨트롤러 찾고 `controller.process(request, response);` 호출해 해당 컨트롤러 실행

## V2 - View 분리
모든 컨트롤러에서 뷰로 이동하는 부분에 중복이 있음

```java
    String viewPath = "/WEB-INF/views/new-form.jsp";
    RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
    dispatcher.forward(request, response);
```
이 부분을 분리해보자

### 분석
- MyView 클래스를 만들어 중복 부분을 해결
- 컨트롤러는 복잡한 `dispatcher.forward()`를 직업 생성해서 호출하지 않음.
- MyView 객체 생성하고 거기에 뷰 이름만 넣고 반환
- V1에 비교해 중복부분 확실히 제거됨
- 프론트 컨트롤러에서 `view.render()`를 호출해 `forward`로직 수행

## V3 - Model 추가

### 서블릿 종속성 제거
- 컨트롤러 입장에서 HttpServletRequest, HttpServletResponse이 필요할까?
- 요청 파라미터 정보는 Map으로 대신 넘기도록 하면 지금 구조에서는 컨트롤러가 서블릿 기술을 몰라도 동작 가능
- request 객체를 Model로 사용하는 대신 별도의 Model 객체 만들어 반환하면 됨.

### 뷰 이름 중복 제거
- 뷰의 논리 이름 반환하고, 실제 물리 위치 이름은 프론트 컨트롤러에서 처리하도록 단순화
  - `/WEB-INF/views/new-form.jsp` -> new-form
  - `/WEB-INF/views/save-result.jsp` -> save-result
  - `/WEB-INF/views/members.jsp` -> members

### 구조
- ModelView: 서블릿 종속성을 제거하기 위해 Model을 직접 만들고, 추가로 View 이름까지 전달하는 객체를 만듦.
- ControllerV3: 컨트롤러는 서블릿 기술을 전혀 사용하지 않고 HttpServeltRequest가 제공하는 파라미터는 프론트 컨트롤러가 paramMap에 담아서 호출해준다.
- 뷰 리졸버: 컨트롤러가 반환한 논리 뷰 이름을 실제 물리 뷰로 변경.
- MyView: `render()`에서 Model에 들어온 값들을 RequsetAttribute에 담아준다.

## V4 - 단순하고 실용적인 컨트롤러
- v3 컨트롤러는 서블릿 종속성을 제거하고 뷰 경로의 중복을 제거했다.
- 그런데 인터페이스 구현 개발자 입장에서는 항상 ModelView객체를 생성해야 하고 반환해야 하는 부분이 조금 번거롭다.
- 이번에는 컨트롤러가 `ModelView` 반환하지 않고, `ViewName`만 반환한다.
- 이번 버전은 인터페이스에 ModelView가 없기 때문에 model은 직접 생성하지 않고 파라미터로 전달해 사용한다.
- 컨트롤러는 단순하게 뷰의 논리 이름만 반환한다.

기존 구조에서 모델을 파라미터로 넘기고, 뷰의 논리 이름을 반환한다는 아이디어를 적용해 컨트롤러 구현하는 개발자는 군더더기 없는 코드 작성 가능!!

## V5 - 유연한 컨트롤러

### 어댑터 패턴
전혀 다른 인터페이스를 호환할 수 있도록 만들어주는 패턴. 이 패턴을 사용해 프론트 컨트롤러가 다양한 방식의 컨트롤러 처리 가능

- 핸들러 어댑터: 중간에 어댑터 역할. 여기서 다양한 종류의 컨트롤러를 호출할 수 있음.
- 핸들러: 컨트롤러의 이름을 더 넓은 범위인 핸들러로 변경. 어댑터가 있기 떄문에 꼭 컨틀로러 개념 뿐 아니라 어떤 것이든 해당 종류의 어댑터만 있으면 처리 가능하기 떄문

### MyHandlerAdapter
- `boolean supports(Object handler)`
  - handler는 컨트롤러를 말함
  - 어댑터가 해당 컨트롤러를 처리할 수 있는지 판단하는 메서드
- `ModelView handle(HttpServletRequest request, HttpServletResponse response, Object handler)`
  - 어댑터는 실제 컨트롤러를 호출하고, 그 결과로 ModelView 반환
  - 실제 컨트롤러가 ModelView 반환하지 못하면, 어댑터가 ModelView를 직접 생성해서라도 반환
  - 프론트 컨트롤러가 실제 컨트롤러를 호출했지만 이제 이 어댑터를 통해 실제 컨트롤러 호출

### 프론트 컨트롤러
- 컨트롤러 -> 핸들러: 이전에는 컨트롤러를 직접 매핑해서 사용했지만 이제는 어댑터를 사용하기 떄문에 컨트롤러 뿐만 아니라 어댑터가 지원하기만 하면, 어떤 것이라도 URL에 매핑해 사용 가능
- 생성자: 핸들러 매핑과 어댑터를 초기화함.
- 매핑 정보: 매핑 정보 값이 어떤 인터페이스에서의 아무 값이나 받을 수 있도록 `Object`로 변경
- 핸들러 매핑: 핸들러 매핑 정보인 `handlerMappingMap`에서 URL에 매핑된 핸들러 객체 찾아 반환
- 핸들러 처리할 어댑터 조회: `handler`를 처리할 수 있는 어댑터를 `adapter.supports(handler)` 통해서 찾음
- 어댑터 호출: 어댑터의 `handle(request, response, handler)`를 호출하고 어댑터에 맞춰 반환

---